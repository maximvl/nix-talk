* Слайд вступительный
  Деплой софта это одна из таких сфер в IT, которая полностью была отдана на откуп сисадминам и unix-хакерам,
  что привело к большому количеству костылей для автоматизации ручного процесса,
  но не для решения фундаментальных проблем с систематизированным подходом.

  И никаких серьезных исследований в этой сфере не проводилось. До недавнего времени.

  Стоит отметить, что подход о котором я буду рассказывать является одним из редких примеров,
  когда идея "все существующие решения поломаны, никуда не годится и мы сделаем все с нуля"
  действительно сработала, во многом благодаря серьезному, научному подходу к проблеме,
  и детальному изучению существующих решений, даже самых экзотических, о которых я даже не слышал.
* Слайд проблемы
  Что такое деплой софта? Разработчик написал какой-то софт, и он должен попасть на компьютер пользователя.
  Этот софт может быть установлен, обновлен или удален.
  Деплой корректен когда софт на машине пользователя работает точно так, как и на машине разработчика.
  Это должно быть простой проблемой, например для софт состоящего из набора файлов - деплой должен
  заключаться просто в копировании этих файлов.
  На практике же все намного сложнее. Есть две категории проблем:
  * Проблемы окружения
  * Проблемы управления
* Слайд проблемы окружения
  Проблемы этой категории наиболее критичны для корректного деплоя.
  Программы имеют кучу требований к среде в которой они выполняются:
  * наличие других программ
  * наличие конфигурационных файлов
  * и тд
  И если какое-то из этих требований не выполняется - нет гарантий что программа
  заработает так же как у разработчика.

  * Зависимости
    Для корректного деплоя нужно чтобы все зависимости былы указаны. Это как оказалось
    не тривиальная задача, так как трудно проверить полноту указанных зависимостей.
    Например, если компонент зависит от нескольких других, и они установлены на системе разработчика,
    и если не будет указана одна из зависимостей, то тесты пройдут, а пакет получится в общем случае нерабочим.

    В общем случае зависимости могут быть не только runtime, но и compiletime, для source-based пакетов.

  * Зависимости так же должны быть совместимы с тем что ожидает компонент.
    В общем случае не все версии зависимостей подойдут для конкретного компонента.
    Так же, компоненты часто имеют возможность конфигурирования в процессе сборке,
    что еще больше усложняет указание зависимостей.
    И в худшем случае может требоваться чтобы зависимость была собрана
    специфичным компилятором со специфичными опциями (для ABI-совместимости)

  * Даже если все зависимости указаны корректно, их все еще нужно найти на машине пользователя
    Это включает в себя все проблемы с управлением путями поиска зависимостей

  На этом этапе необходимо выяснить какие зависимости отсутствуют в пользовательском окружении и как-то удовлетворить их.

* Слайд проблемы управления
  Дальше у нас есть пакеты, ими нужно управлять.
  Надо доставлять их к пользователю, устанавливать, обновлять, запрашивать информацию итд

  * Удаление
    Проблема с удалением состоит в том, чтобы откатить изменения сделанные пакетом,
    но только в том случае если это не повлияет на работу других компонентов.
  * Обновление
    Так же, при обновлении хочется иметь гарантию что никакие други компоненты
    не будут затронуты. Эта проблема хорошо известна как DLL-hell, когда
    установки или обновление одного компонента вызывает поломку в другом из-за
    общих используемых библиотек.
  * Пользователю необходима возможность выполнять запросы типа "сколько места занимает этот компонент",
    "из каких компонентов был собран этот"
  * Откат изменений
    Если компонент каким-либо образом не заработал, необходимо иметь возможность откатиться на предыдущее состояние
  *
